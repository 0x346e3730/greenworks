#include "CUtils.h"

using namespace std;
using namespace v8;


bool CUtils::WriteToJsEnabled = false;
bool CUtils::WriteToLogEnabled = false;
string CUtils::WriteToLogFileLocation = "";

void CUtils::WriteToJsConsole(string msg){
	if (!WriteToJsEnabled){
		return;
	}
    
	std::stringstream ss;
	ss << "console.log('" << msg << "'); ";

	Handle<Script> script = Script::Compile(String::New(ss.str().c_str()));
	Handle<Value> result = script->Run();
}

void CUtils::WriteToLogFile(string msg){
	if (!WriteToLogEnabled){
		return;
	}

	FILE* pFile = fopen(WriteToLogFileLocation.c_str(), "a");
	fprintf(pFile, "%s\n", msg.c_str());
	fclose(pFile);
}

void CUtils::WriteToJsConsoleAndLogFile(string msg){
	WriteToJsConsole(msg);
	WriteToLogFile(msg);
}

// Get the size of a file
long CUtils::FileSize(FILE *file)
{
		long lCurPos, lEndPos;
		lCurPos = ftell(file);
		fseek(file, 0, 2);
		lEndPos = ftell(file);
		fseek(file, lCurPos, 0);
		return lEndPos;
}

BYTE* CUtils::FileBuffer(FILE *file){
	// Get the size of the file in bytes
	long fileSize = CUtils::FileSize(file);

	// Allocate space in the buffer for the whole file
	BYTE *fileBuf = new BYTE[fileSize];

	// Read the file in to the buffer
	fread(fileBuf, fileSize, 1, file);

	return fileBuf;
}

void CUtils::FileClose(FILE *file){
	fclose(file);

}

FILE CUtils::FileOpen(const char* fileName)
{
	FILE *file = NULL;      // File pointer

	// Open the file in binary mode using the "rb" format string
	// This also checks if the file exists and/or can be opened for reading correctly
	if ((file = fopen(fileName, "rb")) == NULL)
		cout << "Could not open specified file" << endl;
	else
		cout << "File opened successfully" << endl;

	return *file;
}

string CUtils::ToString(const char *str){
	return string(str);
}

int CUtils::ToInt(const char *str) {
	stringstream ss(str); // Could of course also have done ss("1234") directly.

	int i;
	ss >> i;

	return i;
}


long CUtils::ToLong(const char *str) {
	stringstream ss(str); // Could of course also have done ss("1234") directly.

	long i;
	ss >> i;

	return i;
}

uint64 CUtils::ToUInt64(const char *str) {
	stringstream ss(str); // Could of course also have done ss("1234") directly.

	uint64 i;
	ss >> i;

	return i;
}

string CUtils::Replace(string &s, string toReplace,	string replaceWith)
{
	return(s.replace(s.find(toReplace), toReplace.length(), replaceWith));
}

string CUtils::GetFilename(string path) {
	string sFilename = path.substr(path.find_last_of("/\\") + 1);
	return sFilename;
}

string CUtils::PathCombine(string path1, string path2){
	char path[PATH_MAX];

	strcpy(path, path1.c_str());
#ifdef _WIN32 
	strcat(path, "\\\\");
#else
	strcat(path, "/");
#endif
	strcat(path, path2.c_str());

	puts(path);

	return path;
}
/*
** Does not generate hex character constants.
** Always generates triple-digit octal constants.
** Always generates escapes in preference to octal.
** Escape question mark to ensure no trigraphs are generated by repetitive use.
** Handling of 0x80..0xFF is locale-dependent (might be octal, might be literal).
*/
void CUtils::EscapeSingleChar(unsigned char u, char *buffer, size_t buflen)
{
	if (buflen < 2)
		*buffer = '\0';
	else if (isprint(u) && u != '\'' && u != '\"' && u != '\\' && u != '\?')
		sprintf(buffer, "%c", u);
	else if (buflen < 3)
		*buffer = '\0';
	else
	{
		switch (u)
		{
		case '\a':  strcpy(buffer, "\\a"); break;
		case '\b':  strcpy(buffer, "\\b"); break;
		case '\f':  strcpy(buffer, "\\f"); break;
		case '\n':  strcpy(buffer, "\\n"); break;
		case '\r':  strcpy(buffer, "\\r"); break;
		case '\t':  strcpy(buffer, "\\t"); break;
		case '\v':  strcpy(buffer, "\\v"); break;
		case '\\':  strcpy(buffer, "\\\\"); break;
		case '\'':  strcpy(buffer, "\\'"); break;
		case '\"':  strcpy(buffer, "\\\""); break;
		case '\?':  strcpy(buffer, "\\\?"); break;
		default:
			if (buflen < 5)
				*buffer = '\0';
			else
				sprintf(buffer, "\\%03o", u);
			break;
		}
	}
}

string CUtils::Escape(const string& s)
{
    int n = s.size(), wp = 0;
	if (n <= 0){
		return s;
	}

	std::vector<char> result(n*2);
    for (int i=0; i<n; i++)
    {
        if (s[i] == '\\')
            result[wp++] = '\\';
        result[wp++] = s[i];
    }
    return std::string(&result[0], &result[wp]);
}

int CUtils::GetFileTime(const char* file){
	if (!FileExists(file)){
		return 0;
	}

	struct stat st;
	int ierr = stat(file, &st);

	if (ierr != 0) {
		// An error occured trying to read file
	}

	return st.st_mtime;
}

bool CUtils::FileExists(const char* file){
	struct stat buffer;
	return (stat(file, &buffer) == 0);
}

bool CUtils::DirectoryExists(const char* dir)
{
	string directory(dir);

	if (!directory.empty())
	{
		if (access(directory.c_str(), 0) == 0)
		{
			struct stat status;
			stat(directory.c_str(), &status);
			if (status.st_mode & S_IFDIR)
				return true;
		}
	}
	// if any condition fails
	return false;
}

vector<string> CUtils::GetDirectoryList(const string& dir)
{
	DIR * d;
	vector<string> ret;

	/* Open the directory specified by "dir_name". */
	d = opendir(dir.c_str());

	/* Check it was opened. */
	if (!d) {
		// fprintf(stderr, "Cannot open directory '%s': %s\n", dir, strerror(errno));
		exit(EXIT_FAILURE);
	}

	while (1) {
		struct dirent * entry;
		const char * d_name;

		/* "Readdir" gets subsequent entries from "d". */
		entry = readdir(d);

		if (!entry) {
			/* There are no more entries in this directory, so break out of the while loop. */
			break;
		}

		d_name = entry->d_name;

		/* See if "entry" is a subdirectory of "d". */
		if (entry->d_type & DT_DIR) {

			/* Check that the directory is not "d" or d's parent. */
			if (strcmp(d_name, "..") != 0 && strcmp(d_name, ".") != 0) {
				int path_length;
				char path[PATH_MAX];

				strcpy(path, dir.c_str());
#ifdef WIN32
				strcat(path, "\\\\");
#else
				strcat(path, "/");
#endif
				strcat(path, d_name);

				puts(path);

				path_length = strlen(path);

				if (path_length >= PATH_MAX) {
					fprintf(stderr, "Path length has got too long.\n");
					exit(EXIT_FAILURE);
				}
		
				vector<string> rret = GetDirectoryList(path);
				ret.insert(ret.end(), rret.begin(), rret.end());
			}
		}
		else {
			ret.push_back(PathCombine(dir, entry->d_name));
		}
	}
	/* After going through all the entries, close the directory. */
	if (closedir(d)) {
		// fprintf(stderr, "Could not close '%s': %s\n", dir, strerror(errno));
		exit(EXIT_FAILURE);
	}

	return ret;
}

bool CUtils::IsFileNewer(const char* file1, const char* file2) {
	// Non existent files causes the method to return FALSE
	// Please use FileExists prior to use IsFileNewer to make
	// sure the file exists and eventually handle related errors.
	//

	if (!FileExists(file1) || !FileExists(file2)){
		return false;
	}

	FILE hFile1 = FileOpen(file1);
	FILE hFile2 = FileOpen(file2);

	long siz1 = FileSize(&hFile1);
	long siz2 = FileSize(&hFile2);

	FileClose(&hFile1);
	FileClose(&hFile2);

	int date1 = GetFileTime(file1);
	int date2 = GetFileTime(file2);

	return date1 > date2;
}

// Cross-Platform Sleep
void CUtils::Sleep(int ms) {

#ifdef _WIN32
	chrono::milliseconds dura(ms);
	this_thread::sleep_for(dura);
#else
	usleep(ms * 1000);   // usleep takes sleep time in us (1 millionth of a second)
#endif

}
